# Optimized Dockerfile using golden base image
# Uses pcioasis-operations/containers/go-base for better caching
# Note: This service is built from the repo root, not from the service directory

# Declare build arguments at the top
ARG BASE_IMAGE=us-central1-docker.pkg.dev/pcioasis-operations/containers/go-base:latest
ARG ALPINE_BASE=us-central1-docker.pkg.dev/pcioasis-operations/containers/alpine-base:latest

FROM ${BASE_IMAGE} AS builder

# Set working directory
WORKDIR /app

# Configure Go environment with retry-friendly settings
# Use multiple proxies with fallback, and set longer timeouts
ENV GOPROXY=https://proxy.golang.org,direct \
    GOSUMDB=sum.golang.org \
    GOPRIVATE= \
    GONOPROXY= \
    GONOSUMDB= \
    CGO_ENABLED=0 \
    GOOS=linux \
    GOARCH=amd64

# Copy go.mod and go.sum from the home-index-service directory
COPY deploy/shared-components/home-index-service/go.mod ./
# Copy go.sum if it exists (wildcard won't fail if file doesn't exist)
COPY deploy/shared-components/home-index-service/go.sum* ./

# Download dependencies with retry logic to handle transient network errors
# Retry up to 5 times with exponential backoff (2s, 4s, 6s, 8s, 10s delays)
RUN for i in 1 2 3 4 5; do \
        echo "Attempt $i/5: Downloading Go modules..."; \
        if go mod download 2>&1; then \
            echo "✓ Successfully downloaded modules on attempt $i"; \
            exit 0; \
        else \
            exit_code=$?; \
            if [ $i -eq 5 ]; then \
                echo "✗ All 5 attempts failed (exit code: $exit_code). Check network connectivity and Go proxy settings."; \
                exit 1; \
            else \
                wait_time=$((i * 2)); \
                echo "✗ Attempt $i failed (exit code: $exit_code). Waiting ${wait_time}s before retry..."; \
                sleep $wait_time; \
            fi; \
        fi; \
    done

# Copy source code from the home-index-service directory
COPY deploy/shared-components/home-index-service/ .

# Verify go.mod is valid and update if needed (non-fatal if tidy makes changes)
RUN go mod verify && go mod tidy || true

# Build the application
RUN go build -a -installsuffix cgo -o main .

# Final stage using alpine-base
FROM ${ALPINE_BASE} AS runtime

# Create app directory
WORKDIR /app

# Copy the binary from builder stage
COPY --from=builder /app/main .

# Copy the docs directory for MITRE ATT&CK and threat model pages
COPY docs ./docs

# Create labs directory structure (lab READMEs are optional)
# Note: labs/ may be excluded by .dockerignore, so we create empty structure
RUN mkdir -p ./docs/labs

# Copy catalog info for service metadata
# The file must exist in the repo root (build context is .)
# It should be generated by scripts/generate-catalog-info.sh before building
# This will fail if catalog-info.yaml is not present - ensure it's generated in CI/CD
COPY catalog-info.yaml ./catalog-info.yaml

# Set ownership (alpine-base already has appuser)
RUN chown -R appuser:appuser /app
USER appuser

# Expose port
EXPOSE 8080

# Health check (alpine-base has wget pre-installed)
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:8080/health || exit 1

# Run the application
CMD ["./main"]

