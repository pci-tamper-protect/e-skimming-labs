#!/bin/bash
# Generate Traefik routes.yml from Cloud Run service labels
# This script queries Cloud Run services and extracts Traefik routing labels
# to generate a routes.yml file that matches docker-compose.yml behavior

set -e

ENVIRONMENT="${ENVIRONMENT:-stg}"
PROJECT_ID="${LABS_PROJECT_ID:-labs-${ENVIRONMENT}}"
HOME_PROJECT_ID="${HOME_PROJECT_ID:-labs-home-${ENVIRONMENT}}"
REGION="${REGION:-us-central1}"
OUTPUT_FILE="${1:-/etc/traefik/dynamic/routes.yml}"

echo "ðŸ” Generating Traefik routes from Cloud Run service labels..."
echo "   Environment: ${ENVIRONMENT}"
echo "   Labs Project: ${PROJECT_ID}"
echo "   Home Project: ${HOME_PROJECT_ID}"
echo "   Region: ${REGION}"
echo "   Output: ${OUTPUT_FILE}"
echo ""

# Create output directory
mkdir -p "$(dirname "$OUTPUT_FILE")"

# Rule identifier to actual rule mapping
# This allows us to use short identifiers in GCP labels (63 char limit)
declare -A RULE_MAP
RULE_MAP["home-index-root"]="PathPrefix(\`/\`)"
RULE_MAP["home-index-signin"]="Path(\`/sign-in\`) || Path(\`/sign-up\`)"
RULE_MAP["home-seo"]="PathPrefix(\`/api/seo\`)"
RULE_MAP["labs-analytics"]="PathPrefix(\`/api/analytics\`)"
RULE_MAP["lab1"]="PathPrefix(\`/lab1\`)"
RULE_MAP["lab1-static"]="PathPrefix(\`/lab1/css/\`) || PathPrefix(\`/lab1/js/\`) || PathPrefix(\`/lab1/images/\`) || PathPrefix(\`/lab1/img/\`) || PathPrefix(\`/lab1/static/\`) || PathPrefix(\`/lab1/assets/\`)"
RULE_MAP["lab1-c2"]="PathPrefix(\`/lab1/c2\`)"
RULE_MAP["lab2"]="PathPrefix(\`/lab2\`)"
RULE_MAP["lab2-static"]="PathPrefix(\`/lab2/css/\`) || PathPrefix(\`/lab2/js/\`) || PathPrefix(\`/lab2/images/\`) || PathPrefix(\`/lab2/img/\`) || PathPrefix(\`/lab2/static/\`) || PathPrefix(\`/lab2/assets/\`)"
RULE_MAP["lab2-c2"]="PathPrefix(\`/lab2/c2\`)"
RULE_MAP["lab3"]="PathPrefix(\`/lab3\`)"
RULE_MAP["lab3-static"]="PathPrefix(\`/lab3/css/\`) || PathPrefix(\`/lab3/js/\`) || PathPrefix(\`/lab3/images/\`) || PathPrefix(\`/lab3/img/\`) || PathPrefix(\`/lab3/static/\`) || PathPrefix(\`/lab3/assets/\`)"

# Function to get identity token for a service URL
get_identity_token() {
  local service_url=$1
  if [ -z "$service_url" ] || [[ "$service_url" == http://localhost* ]]; then
    echo ""
    return
  fi

  local encoded_audience=$(echo -n "$service_url" | sed 's/:/%3A/g; s/\//%2F/g')
  local metadata_url="http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/identity?audience=${encoded_audience}"
  local token=$(curl -s -f -H "Metadata-Flavor: Google" "$metadata_url" 2>/dev/null || echo "")

  if [[ "$token" =~ ^eyJ ]]; then
    echo "$token"
  else
    echo ""
  fi
}

# Start generating routes.yml
cat > "$OUTPUT_FILE" <<ROUTES_EOF
# Auto-generated Traefik routes from Cloud Run service labels
# Generated at: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
# Environment: ${ENVIRONMENT}
#
# This file is generated by reading Traefik labels from Cloud Run services.
# Labels follow the same format as docker-compose.yml

http:
  routers:
ROUTES_EOF

# Query services and extract Traefik labels
# For each service with traefik.enable=true, extract router and service config
echo "ðŸ” Querying Cloud Run services for Traefik labels..."

# Get all services from both projects
ALL_SERVICES=""

if [ -n "$HOME_PROJECT_ID" ]; then
  HOME_SERVICES=$(gcloud run services list \
    --region="${REGION}" \
    --project="${HOME_PROJECT_ID}" \
    --format="value(name)" 2>/dev/null || echo "")
  while IFS= read -r svc; do
    if [ -n "$svc" ]; then
      ALL_SERVICES+="${svc}|${HOME_PROJECT_ID}"$'\n'
    fi
  done <<< "$HOME_SERVICES"
fi

if [ -n "$PROJECT_ID" ]; then
  LABS_SERVICES=$(gcloud run services list \
    --region="${REGION}" \
    --project="${PROJECT_ID}" \
    --format="value(name)" 2>/dev/null || echo "")
  while IFS= read -r svc; do
    if [ -n "$svc" ]; then
      ALL_SERVICES+="${svc}|${PROJECT_ID}"$'\n'
    fi
  done <<< "$LABS_SERVICES"
fi

# Process each service
declare -A processed_services
declare -A auth_middlewares

while IFS='|' read -r service_name project_id; do
  if [ -z "$service_name" ] || [ -z "$project_id" ]; then
    continue
  fi

  # Skip if service doesn't exist (handles services not yet deployed)
  if ! gcloud run services describe "${service_name}" \
    --region="${REGION}" \
    --project="${project_id}" \
    --format="value(name)" >/dev/null 2>&1; then
    echo "  âšª Service ${service_name} not found, skipping" >&2
    continue
  fi

  echo "  ðŸ“‹ Processing: ${service_name} (${project_id})" >&2

  # Get service JSON (with retry for transient errors)
  service_json=""
  for attempt in 1 2 3; do
    service_json=$(gcloud run services describe "${service_name}" \
      --region="${REGION}" \
      --project="${project_id}" \
      --format="json" 2>/dev/null || echo "")

    if [ -n "$service_json" ] && [ "$service_json" != "{}" ]; then
      break
    fi

    if [ $attempt -lt 3 ]; then
      echo "    â³ Retry $attempt/3 for ${service_name}..." >&2
      sleep 1
    fi
  done

  if [ -z "$service_json" ] || [ "$service_json" = "{}" ]; then
    echo "    âš ï¸  Could not fetch service details after retries, skipping" >&2
    continue
  fi

  # Check if traefik_enable=true (using underscore for GCP label compatibility)
  traefik_enable=$(echo "$service_json" | jq -r '.spec.template.metadata.labels["traefik_enable"] // "false"' 2>/dev/null || echo "false")

  if [ "$traefik_enable" != "true" ]; then
    echo "    âšª traefik_enable=${traefik_enable}, skipping" >&2
    continue
  fi

  # Get service URL
  service_url=$(echo "$service_json" | jq -r '.status.url // ""' 2>/dev/null || echo "")
  if [ -z "$service_url" ]; then
    echo "    âš ï¸  No service URL found" >&2
    continue
  fi

  echo "    âœ… Found Traefik-enabled service: ${service_url}" >&2

  # Extract all labels
  labels_json=$(echo "$service_json" | jq -r '.spec.template.metadata.labels // {}' 2>/dev/null || echo "{}")

  # Extract router labels (traefik_http_routers_* - using underscore for GCP label compatibility)
  router_keys=$(echo "$labels_json" | jq -r 'keys[] | select(startswith("traefik_http_routers_"))' 2>/dev/null || echo "")

  if [ -z "$router_keys" ]; then
    echo "    âš ï¸  No router labels found" >&2
    continue
  fi

  # Group routers by router name
  # Format: traefik_http_routers_<router-name>_<property>
  declare -A routers
  while IFS= read -r key; do
    # Match pattern: traefik_http_routers_<router-name>_<property>
    # Router name can contain dashes, property is the last segment after final underscore
    if [[ "$key" =~ ^traefik_http_routers_(.+)_(.+)$ ]]; then
      router_name="${BASH_REMATCH[1]}"
      property="${BASH_REMATCH[2]}"
      value=$(echo "$labels_json" | jq -r ".[\"${key}\"]" 2>/dev/null || echo "")

      if [ -z "${routers[$router_name]}" ]; then
        routers[$router_name]=""
      fi
      routers[$router_name]+="${property}=${value}"$'\n'
    fi
  done <<< "$router_keys"

  # Generate router configs
  for router_name in "${!routers[@]}"; do
    config="${routers[$router_name]}"

    # Extract properties
    # Rule may be a short identifier (mapped via RULE_MAP) or plain text
    rule_raw=$(echo "$config" | grep "^rule=" | cut -d'=' -f2- | sed "s/^'//; s/'$//" || echo "")
    rule_id=$(echo "$config" | grep "^rule_id=" | cut -d'=' -f2- | sed "s/^'//; s/'$//" || echo "")

    # Look up rule by identifier if present, otherwise use raw value
    if [ -n "$rule_id" ] && [ -n "${RULE_MAP[$rule_id]}" ]; then
      rule="${RULE_MAP[$rule_id]}"
    else
      rule="$rule_raw"
    fi

    priority=$(echo "$config" | grep "^priority=" | cut -d'=' -f2 || echo "1")
    entrypoints=$(echo "$config" | grep "^entrypoints=" | cut -d'=' -f2 || echo "web")
    middlewares=$(echo "$config" | grep "^middlewares=" | cut -d'=' -f2 || echo "")
    service_name_from_label=$(echo "$config" | grep "^service=" | cut -d'=' -f2 || echo "${service_name}")

    # Generate router YAML
    cat >> "$OUTPUT_FILE" <<ROUTER_EOF
    ${router_name}:
      rule: ${rule}
      service: ${service_name_from_label}
      priority: ${priority}
      entryPoints:
        - ${entrypoints}
ROUTER_EOF

    # Add middlewares if present
    if [ -n "$middlewares" ]; then
      echo "      middlewares:" >> "$OUTPUT_FILE"
      IFS=',' read -ra MW_ARRAY <<< "$middlewares"
      for mw in "${MW_ARRAY[@]}"; do
        # Convert -file back to @file (GCP labels use -file instead of @file for compatibility)
        # Trim whitespace and convert -file suffix to @file
        mw_trimmed=$(echo "$mw" | xargs)
        if [[ "$mw_trimmed" =~ -file$ ]]; then
          mw_clean="${mw_trimmed%-file}@file"
        else
          mw_clean="$mw_trimmed"
        fi
        echo "        - ${mw_clean}" >> "$OUTPUT_FILE"
      done
      # Add retry middleware for cold start support (unless already present)
      if [[ ! "$middlewares" =~ retry-cold-start ]]; then
        echo "        - retry-cold-start@file" >> "$OUTPUT_FILE"
      fi
    else
      # Add retry middleware even if no other middlewares
      echo "      middlewares:" >> "$OUTPUT_FILE"
      echo "        - retry-cold-start@file" >> "$OUTPUT_FILE"
    fi
  done

  # Generate service definition
  # Format: traefik_http_services_<service-name>_loadbalancer_server_port
  service_port=$(echo "$labels_json" | jq -r '.["traefik_http_services_'${service_name}'_loadbalancer_server_port"] // "8080"' 2>/dev/null || echo "8080")

  # Check if service already defined
  if [ -z "${processed_services[$service_name_from_label]}" ]; then
    processed_services[$service_name_from_label]=1

    # Get identity token for auth
    token=$(get_identity_token "$service_url")

    # Add service definition
    cat >> "$OUTPUT_FILE" <<SERVICE_EOF

  services:
    ${service_name_from_label}:
      loadBalancer:
        servers:
          - url: "${service_url}"
        passHostHeader: false
SERVICE_EOF

    # Generate auth middleware if token exists
    if [ -n "$token" ] && [ -z "${auth_middlewares[$service_name_from_label]}" ]; then
      auth_middlewares[$service_name_from_label]=1
      token_esc=$(echo -n "$token" | sed 's/"/\\"/g')

      # Check if middlewares section exists
      if ! grep -q "^  middlewares:" "$OUTPUT_FILE"; then
        echo "" >> "$OUTPUT_FILE"
        echo "  middlewares:" >> "$OUTPUT_FILE"
      fi

      cat >> "$OUTPUT_FILE" <<AUTH_EOF
    ${service_name_from_label}-auth:
      headers:
        customRequestHeaders:
          Authorization: "Bearer ${token_esc}"
AUTH_EOF
    fi
  fi

  # Clear routers array for next service
  unset routers
  declare -A routers

done <<< "$ALL_SERVICES"

echo ""
echo "âœ… Routes file generated at ${OUTPUT_FILE}"
echo ""
echo "ðŸ“Š Summary:"
router_count=$(grep -c "^    [a-z]" "$OUTPUT_FILE" 2>/dev/null || echo "0")
service_count=$(grep -c "      - url:" "$OUTPUT_FILE" 2>/dev/null || echo "0")
echo "   Routers: ${router_count}"
echo "   Services: ${service_count}"
