#!/bin/bash
# Generate Traefik routes.yml from Cloud Run service labels
# This script queries Cloud Run services and extracts Traefik routing labels
# to generate a routes.yml file that matches docker-compose.yml behavior

# Don't use set -e - we want to see where failures occur
# set -e

# Redirect all output to stderr so Cloud Run captures it
exec 1>&2

# Log script startup - this log is used by debug scripts to verify execution
echo "ðŸš€ Starting generate-routes-from-labels.sh at $(date -u +"%Y-%m-%dT%H:%M:%SZ")" >&2

ENVIRONMENT="${ENVIRONMENT:-stg}"
PROJECT_ID="${LABS_PROJECT_ID:-labs-${ENVIRONMENT}}"
HOME_PROJECT_ID="${HOME_PROJECT_ID:-labs-home-${ENVIRONMENT}}"
REGION="${REGION:-us-central1}"
OUTPUT_FILE="${1:-/etc/traefik/dynamic/routes.yml}"

echo "ðŸ” Generating Traefik routes from Cloud Run service labels..."
echo "   Environment: ${ENVIRONMENT}"
echo "   Labs Project: ${PROJECT_ID}"
echo "   Home Project: ${HOME_PROJECT_ID}"
echo "   Region: ${REGION}"
echo "   Output: ${OUTPUT_FILE}"
echo ""
echo "   DEBUG: Script started at $(date -u +"%Y-%m-%dT%H:%M:%SZ")"
echo "   DEBUG: Current user: $(whoami)"
echo "   DEBUG: Working directory: $(pwd)"
echo "   DEBUG: Using Cloud Run Admin API REST endpoints (gcloud not needed)"
echo "   DEBUG: jq available: $(command -v jq >/dev/null && echo "yes" || echo "no")"
echo "   DEBUG: Output directory exists: $([ -d "$(dirname "$OUTPUT_FILE")" ] && echo "yes" || echo "no")"
echo "   DEBUG: Output directory writable: $([ -w "$(dirname "$OUTPUT_FILE")" ] && echo "yes" || echo "no")"
echo ""

# Create output directory
mkdir -p "$(dirname "$OUTPUT_FILE")"

# Rule identifier to actual rule mapping
# This allows us to use short identifiers in GCP labels (63 char limit)
declare -A RULE_MAP
RULE_MAP["home-index-root"]="PathPrefix(\`/\`)"
RULE_MAP["home-index-signin"]="Path(\`/sign-in\`) || Path(\`/sign-up\`)"
RULE_MAP["home-seo"]="PathPrefix(\`/api/seo\`)"
RULE_MAP["labs-analytics"]="PathPrefix(\`/api/analytics\`)"
RULE_MAP["lab1"]="PathPrefix(\`/lab1\`)"
RULE_MAP["lab1-static"]="PathPrefix(\`/lab1/css/\`) || PathPrefix(\`/lab1/js/\`) || PathPrefix(\`/lab1/images/\`) || PathPrefix(\`/lab1/img/\`) || PathPrefix(\`/lab1/static/\`) || PathPrefix(\`/lab1/assets/\`)"
RULE_MAP["lab1-c2"]="PathPrefix(\`/lab1/c2\`)"
RULE_MAP["lab2"]="PathPrefix(\`/lab2\`)"
RULE_MAP["lab2-static"]="PathPrefix(\`/lab2/css/\`) || PathPrefix(\`/lab2/js/\`) || PathPrefix(\`/lab2/images/\`) || PathPrefix(\`/lab2/img/\`) || PathPrefix(\`/lab2/static/\`) || PathPrefix(\`/lab2/assets/\`)"
RULE_MAP["lab2-c2"]="PathPrefix(\`/lab2/c2\`)"
RULE_MAP["lab3"]="PathPrefix(\`/lab3\`)"
RULE_MAP["lab3-static"]="PathPrefix(\`/lab3/css/\`) || PathPrefix(\`/lab3/js/\`) || PathPrefix(\`/lab3/images/\`) || PathPrefix(\`/lab3/img/\`) || PathPrefix(\`/lab3/static/\`) || PathPrefix(\`/lab3/assets/\`)"
RULE_MAP["lab3-extension"]="PathPrefix(\`/lab3/extension\`)"

# Function to get access token for Cloud Run Admin API
get_access_token() {
  local token=$(curl -s -f -H "Metadata-Flavor: Google" \
    "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token?scopes=https://www.googleapis.com/auth/cloud-platform" 2>&1 | \
    jq -r '.access_token' 2>/dev/null || echo "")
  echo "$token"
}

# Function to get identity token for a service URL
get_identity_token() {
  local service_url=$1
  if [ -z "$service_url" ] || [[ "$service_url" == http://localhost* ]]; then
    echo ""
    return
  fi

  local encoded_audience=$(echo -n "$service_url" | sed 's/:/%3A/g; s/\//%2F/g')
  local metadata_url="http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/identity?audience=${encoded_audience}"

  # Try to fetch token (works for both public and private Cloud Run services)
  # The metadata server can generate tokens for any service URL
  local token=$(curl -s -f -H "Metadata-Flavor: Google" "$metadata_url" 2>&1)
  local curl_exit=$?

  # Check if we got a valid JWT token
  if [ $curl_exit -eq 0 ] && [[ "$token" =~ ^eyJ ]]; then
    echo "$token"
  else
    # Log error for debugging (but don't fail - middleware will still be created)
    if [ $curl_exit -ne 0 ]; then
      echo "    DEBUG: Token fetch failed with exit code $curl_exit for ${service_url}" >&2
    elif [ -n "$token" ] && [[ ! "$token" =~ ^eyJ ]]; then
      echo "    DEBUG: Token response doesn't look valid: ${token:0:100}" >&2
    fi
    echo ""
  fi
}

# Start generating routes.yml
cat > "$OUTPUT_FILE" <<ROUTES_EOF
# Auto-generated Traefik routes from Cloud Run service labels
# Generated at: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
# Environment: ${ENVIRONMENT}
#
# This file is generated by reading Traefik labels from Cloud Run services.
# Labels follow the same format as docker-compose.yml

http:
  routers:
    # Traefik API and Dashboard routers (high priority to match before application routes)
    # These routes expose Traefik's internal API and dashboard on port 8080
    # Based on: https://community.traefik.io/t/serving-traefiks-internal-dashboard-behind-traefik-itself/3457/7
    # API: /api/http/*, /api/rawdata/*, /api/overview, etc.
    # Dashboard: /dashboard/
    traefik-api:
      rule: "PathPrefix(\`/api/http\`) || PathPrefix(\`/api/rawdata\`) || PathPrefix(\`/api/overview\`) || Path(\`/api/version\`)"
      service: api@internal
      priority: 1000  # High priority to match before application /api/* routes (seo=500, analytics=500)
      entryPoints:
        - web
    traefik-dashboard:
      rule: "PathPrefix(\`/dashboard\`)"
      service: api@internal
      priority: 1000  # High priority
      entryPoints:
        - web
ROUTES_EOF

# Query services and extract Traefik labels
# For each service with traefik.enable=true, extract router and service config
echo "ðŸ” Querying Cloud Run services for Traefik labels..." >&2
echo "   DEBUG: Using Cloud Run Admin API REST endpoints (gcloud not available in container)" >&2
echo "   DEBUG: Will check projects: ${PROJECT_ID} and ${HOME_PROJECT_ID}" >&2
echo "" >&2

# Get access token for Cloud Run Admin API
echo "   DEBUG: Fetching access token for Cloud Run Admin API..." >&2
ACCESS_TOKEN=$(get_access_token)
if [ -z "$ACCESS_TOKEN" ] || [[ ! "$ACCESS_TOKEN" =~ ^ya29\. ]]; then
  echo "   âŒ CRITICAL: Failed to get access token for Cloud Run Admin API" >&2
  echo "   This means the service account cannot query Cloud Run services" >&2
  echo "   Check that the service account has roles/run.viewer permission" >&2
  ACCESS_TOKEN=""
else
  echo "   âœ… Access token obtained (${#ACCESS_TOKEN} chars)" >&2
fi
echo "" >&2

# Get all services from both projects using REST API
ALL_SERVICES=""

# Function to list services via REST API
list_services_via_api() {
  local project_id=$1
  local region=$2
  local access_token=$3

  if [ -z "$access_token" ]; then
    echo ""
    return 1
  fi

  local api_url="https://run.googleapis.com/v1/projects/${project_id}/locations/${region}/services"
  local response=$(curl -s -f -H "Authorization: Bearer ${access_token}" \
    -H "Content-Type: application/json" \
    "$api_url" 2>&1)
  local curl_exit=$?

  if [ $curl_exit -ne 0 ]; then
    echo "   DEBUG: API call failed with exit code $curl_exit" >&2
    echo "   Response: ${response:0:200}" >&2
    echo ""
    return 1
  fi

  # Extract service names from JSON response
  echo "$response" | jq -r '.items[]?.metadata.name // empty' 2>/dev/null || echo ""
}

if [ -n "$HOME_PROJECT_ID" ] && [ -n "$ACCESS_TOKEN" ]; then
  echo "   DEBUG: Querying home project via REST API: ${HOME_PROJECT_ID}" >&2
  HOME_SERVICES=$(list_services_via_api "$HOME_PROJECT_ID" "$REGION" "$ACCESS_TOKEN")
  HOME_SERVICES_EXIT=$?
  echo "   DEBUG: Home services query exit code: ${HOME_SERVICES_EXIT}" >&2
  if [ $HOME_SERVICES_EXIT -ne 0 ] || [ -z "$HOME_SERVICES" ]; then
    echo "   âš ï¸  Warning: Failed to query home project services via REST API" >&2
    HOME_SERVICES=""
  else
    HOME_COUNT=$(echo "$HOME_SERVICES" | grep -c . || echo "0")
    echo "   DEBUG: Found ${HOME_COUNT} service(s) in home project" >&2
  fi
  while IFS= read -r svc; do
    if [ -n "$svc" ]; then
      ALL_SERVICES+="${svc}|${HOME_PROJECT_ID}"$'\n'
    fi
  done <<< "$HOME_SERVICES"
elif [ -n "$HOME_PROJECT_ID" ] && [ -z "$ACCESS_TOKEN" ]; then
  echo "   âš ï¸  Warning: Skipping home project (no access token)" >&2
fi

if [ -n "$PROJECT_ID" ] && [ -n "$ACCESS_TOKEN" ]; then
  echo "   DEBUG: Querying labs project via REST API: ${PROJECT_ID}" >&2
  LABS_SERVICES=$(list_services_via_api "$PROJECT_ID" "$REGION" "$ACCESS_TOKEN")
  LABS_SERVICES_EXIT=$?
  echo "   DEBUG: Labs services query exit code: ${LABS_SERVICES_EXIT}" >&2
  if [ $LABS_SERVICES_EXIT -ne 0 ] || [ -z "$LABS_SERVICES" ]; then
    echo "   âš ï¸  Warning: Failed to query labs project services via REST API" >&2
    LABS_SERVICES=""
  else
    LABS_COUNT=$(echo "$LABS_SERVICES" | grep -c . || echo "0")
    echo "   DEBUG: Found ${LABS_COUNT} service(s) in labs project" >&2
  fi
  while IFS= read -r svc; do
    if [ -n "$svc" ]; then
      ALL_SERVICES+="${svc}|${PROJECT_ID}"$'\n'
    fi
  done <<< "$LABS_SERVICES"
elif [ -n "$PROJECT_ID" ] && [ -z "$ACCESS_TOKEN" ]; then
  echo "   âš ï¸  Warning: Skipping labs project (no access token)" >&2
fi

TOTAL_SERVICES=$(echo "$ALL_SERVICES" | grep -c . || echo "0")
echo "   DEBUG: Total services to check: ${TOTAL_SERVICES}" >&2

if [ "$TOTAL_SERVICES" -eq 0 ]; then
  echo "   âš ï¸  WARNING: No services found to process!" >&2
  echo "   This could mean:" >&2
  echo "     1. Access token not available (check roles/run.viewer permission)" >&2
  echo "     2. No services have traefik_enable=true label" >&2
  echo "     3. Services are in different projects/regions" >&2
  echo "     4. REST API calls failed (check service account permissions)" >&2
  echo "   Will generate empty routes.yml with only Traefik API routes" >&2
fi
echo "" >&2

# Process each service
declare -A processed_services
declare -A auth_middlewares

if [ "$TOTAL_SERVICES" -eq 0 ]; then
  echo "   âš ï¸  Skipping service processing (no services found)" >&2
else
  echo "   ðŸ”„ Processing ${TOTAL_SERVICES} service(s)..." >&2
fi

# Function to get service details via REST API
get_service_via_api() {
  local service_name=$1
  local project_id=$2
  local region=$3
  local access_token=$4

  if [ -z "$access_token" ]; then
    echo ""
    return 1
  fi

  local api_url="https://run.googleapis.com/v1/projects/${project_id}/locations/${region}/services/${service_name}"
  local response=$(curl -s -f -H "Authorization: Bearer ${access_token}" \
    -H "Content-Type: application/json" \
    "$api_url" 2>&1)
  local curl_exit=$?

  if [ $curl_exit -ne 0 ]; then
    echo "   DEBUG: API call failed with exit code $curl_exit" >&2
    echo "   Response: ${response:0:200}" >&2
    echo ""
    return 1
  fi

  echo "$response"
}

while IFS='|' read -r service_name project_id; do
  if [ -z "$service_name" ] || [ -z "$project_id" ]; then
    continue
  fi

  echo "  ðŸ“‹ Processing: ${service_name} (${project_id})" >&2

  # Get service JSON via REST API (with retry for transient errors)
  service_json=""
  if [ -z "$ACCESS_TOKEN" ]; then
    echo "    âŒ CRITICAL: No access token available, cannot query service details" >&2
    echo "    Skipping ${service_name}" >&2
    continue
  fi

  for attempt in 1 2 3; do
    service_json=$(get_service_via_api "${service_name}" "${project_id}" "${REGION}" "$ACCESS_TOKEN")

    if [ -n "$service_json" ] && [ "$service_json" != "{}" ] && echo "$service_json" | jq -e '.metadata.name' >/dev/null 2>&1; then
      break
    fi

    if [ $attempt -lt 3 ]; then
      echo "    â³ Retry $attempt/3 for ${service_name}..." >&2
      sleep 1
    fi
  done

  if [ -z "$service_json" ] || [ "$service_json" = "{}" ] || ! echo "$service_json" | jq -e '.metadata.name' >/dev/null 2>&1; then
    echo "    âŒ FAILURE: Could not fetch service details for ${service_name} after retries, skipping" >&2
    echo "    DEBUG: Service fetch failed - service_json empty or invalid" >&2
    continue
  fi

  echo "    âœ… SUCCESS: Service details fetched for ${service_name}" >&2

  # Check if traefik_enable=true (using underscore for GCP label compatibility)
  traefik_enable=$(echo "$service_json" | jq -r '.spec.template.metadata.labels["traefik_enable"] // "false"' 2>/dev/null || echo "false")
  echo "    DEBUG: Service ${service_name} traefik_enable=${traefik_enable}" >&2

  if [ "$traefik_enable" != "true" ]; then
    echo "    âŒ FAILURE: Service ${service_name} traefik_enable=${traefik_enable} (not 'true'), skipping" >&2
    continue
  fi

  echo "    âœ… SUCCESS: Service ${service_name} has traefik_enable=true, processing..." >&2

  # Get service URL
  # CRITICAL: Use the same URL for both token generation and service definition
  # This ensures the token audience matches the request URL
  service_url=$(echo "$service_json" | jq -r '.status.url // ""' 2>/dev/null || echo "")
  if [ -z "$service_url" ]; then
    echo "    âŒ FAILURE: No service URL found for ${service_name}, skipping" >&2
    continue
  fi
  echo "    âœ… SUCCESS: Service URL found for ${service_name}: ${service_url}" >&2

  echo "    âœ… Found Traefik-enabled service: ${service_url}" >&2
  echo "    ðŸ”— Using URL for both token generation and service definition (audience must match)" >&2

  # Get identity token for auth BEFORE processing routers (so we can add auth middleware to routers)
  # CRITICAL: Token audience is set to service_url, and service definition also uses service_url
  # This ensures the token audience exactly matches the request URL
  # NOTE: We always try to fetch token, even for public services, so middleware is ready when service is made private
  echo "    DEBUG: Attempting to fetch identity token for ${service_name} (URL: ${service_url})" >&2
  service_token=$(get_identity_token "$service_url")
  if [ -n "$service_token" ] && [[ "$service_token" =~ ^eyJ ]]; then
    echo "    âœ… SUCCESS: Identity token fetched for ${service_name} (${#service_token} chars)" >&2
  else
    echo "    âŒ FAILURE: Initial token fetch failed for ${service_name}" >&2
    echo "    DEBUG: Token may be empty or invalid format (service may be public or metadata server unavailable)" >&2
    echo "    ðŸ”„ Retrying token fetch (metadata server may need a moment)..." >&2
    # Retry once after a short delay (metadata server might be temporarily unavailable)
    sleep 1
    service_token=$(get_identity_token "$service_url")
    if [ -n "$service_token" ] && [[ "$service_token" =~ ^eyJ ]]; then
      echo "    âœ… SUCCESS: Identity token fetched on retry for ${service_name} (${#service_token} chars)" >&2
    else
      echo "    âŒ FAILURE: Token fetch failed after retry for ${service_name}" >&2
      echo "    DEBUG: Will still generate middleware structure (token will be fetched at runtime if needed)" >&2
      echo "    ðŸ’¡ Note: Middleware will be created but may need token when service is made private" >&2
      service_token=""
    fi
  fi

  # Extract all labels
  labels_json=$(echo "$service_json" | jq -r '.spec.template.metadata.labels // {}' 2>/dev/null || echo "{}")

  # Extract router labels (traefik_http_routers_* - using underscore for GCP label compatibility)
  router_keys=$(echo "$labels_json" | jq -r 'keys[] | select(startswith("traefik_http_routers_"))' 2>/dev/null || echo "")
  router_count=$(echo "$router_keys" | grep -c . || echo "0")
  echo "    DEBUG: Found ${router_count} router label(s)" >&2

  if [ -z "$router_keys" ]; then
    echo "    âŒ FAILURE: No router labels found for ${service_name}" >&2
    echo "    DEBUG: Available labels: $(echo "$labels_json" | jq -r 'keys[] | select(startswith("traefik_"))' | head -5 | tr '\n' ',' || echo "none")" >&2
    echo "    DEBUG: Service ${service_name} has traefik_enable=true but no traefik_http_routers_* labels" >&2
    continue
  fi
  echo "    âœ… SUCCESS: Found ${router_count} router label(s) for ${service_name}" >&2

  # Group routers by router name
  # Format: traefik_http_routers_<router-name>_<property>
  declare -A routers
  while IFS= read -r key; do
    # Match pattern: traefik_http_routers_<router-name>_<property>
    # Router name can contain dashes, property is the last segment after final underscore
    if [[ "$key" =~ ^traefik_http_routers_(.+)_(.+)$ ]]; then
      router_name="${BASH_REMATCH[1]}"
      property="${BASH_REMATCH[2]}"
      value=$(echo "$labels_json" | jq -r ".[\"${key}\"]" 2>/dev/null || echo "")

      if [ -z "${routers[$router_name]}" ]; then
        routers[$router_name]=""
      fi
      routers[$router_name]+="${property}=${value}"$'\n'
    fi
  done <<< "$router_keys"

  # Generate router configs
  for router_name in "${!routers[@]}"; do
    config="${routers[$router_name]}"

    # Extract properties
    # Rule may be a short identifier (mapped via RULE_MAP) or plain text
    rule_raw=$(echo "$config" | grep "^rule=" | cut -d'=' -f2- | sed "s/^'//; s/'$//" || echo "")
    rule_id=$(echo "$config" | grep "^rule_id=" | cut -d'=' -f2- | sed "s/^'//; s/'$//" || echo "")

    # Look up rule by identifier if present, otherwise use raw value
    if [ -n "$rule_id" ] && [ -n "${RULE_MAP[$rule_id]}" ]; then
      rule="${RULE_MAP[$rule_id]}"
    else
      rule="$rule_raw"
    fi

    priority=$(echo "$config" | grep "^priority=" | cut -d'=' -f2 || echo "1")
    entrypoints=$(echo "$config" | grep "^entrypoints=" | cut -d'=' -f2 || echo "web")
    middlewares=$(echo "$config" | grep "^middlewares=" | cut -d'=' -f2 || echo "")
    service_name_from_label=$(echo "$config" | grep "^service=" | cut -d'=' -f2 || echo "${service_name}")
    echo "    DEBUG: Router ${router_name}: service_name_from_label='${service_name_from_label}'" >&2

    # Always add the auth middleware to routers that use this service (even if token fetch failed)
    # This ensures middleware is ready when service is made private
    # The auth middleware name is <service-name>-auth
    if [ -n "$service_name_from_label" ]; then
      auth_middleware_name="${service_name_from_label}-auth"
      echo "    DEBUG: Router ${router_name}: auth_middleware_name='${auth_middleware_name}'" >&2
      # Add auth middleware if not already in the list
      if [ -n "$middlewares" ]; then
        # Check if auth middleware is already in the list
        # Support multiple separators: __ (double underscore, preferred for GCP), ; (semicolon, legacy), , (comma, legacy)
        if [[ "$middlewares" == *"__"* ]]; then
          SEP="__"
        elif [[ "$middlewares" == *";"* ]]; then
          SEP=";"
        else
          SEP=","
        fi
        if [[ ! "$middlewares" =~ ${auth_middleware_name} ]]; then
          middlewares="${middlewares}${SEP}${auth_middleware_name}"
          if [ -z "$service_token" ]; then
            echo "    âš ï¸  Adding auth middleware to router (token not available yet - will be generated at service definition time)" >&2
          fi
        fi
      else
        # No middlewares yet, add auth middleware
        middlewares="${auth_middleware_name}"
        if [ -z "$service_token" ]; then
          echo "    âš ï¸  Adding auth middleware to router (token not available yet - will be generated at service definition time)" >&2
        fi
      fi
    fi

    # Generate router YAML
    cat >> "$OUTPUT_FILE" <<ROUTER_EOF
    ${router_name}:
      rule: ${rule}
      service: ${service_name_from_label}
      priority: ${priority}
      entryPoints:
        - ${entrypoints}
ROUTER_EOF

    # Add middlewares if present
    if [ -n "$middlewares" ]; then
      echo "      middlewares:" >> "$OUTPUT_FILE"
      # Split on separator: __ (double underscore, preferred for GCP), ; (semicolon, legacy), , (comma, legacy)
      # GCP labels don't allow semicolons or commas, so we use double underscore
      if [[ "$middlewares" == *"__"* ]]; then
        IFS='__' read -ra MW_ARRAY <<< "$middlewares"
      elif [[ "$middlewares" == *";"* ]]; then
        IFS=';' read -ra MW_ARRAY <<< "$middlewares"
      else
        IFS=',' read -ra MW_ARRAY <<< "$middlewares"
      fi
      for mw in "${MW_ARRAY[@]}"; do
        # Convert -file back to @file (GCP labels use -file instead of @file for compatibility)
        # Trim whitespace and convert -file suffix to @file
        mw_trimmed=$(echo "$mw" | xargs)
        if [[ "$mw_trimmed" =~ -file$ ]]; then
          mw_clean="${mw_trimmed%-file}@file"
        else
          mw_clean="$mw_trimmed"
        fi
        echo "        - ${mw_clean}" >> "$OUTPUT_FILE"
      done
      # Add retry middleware for cold start support (unless already present)
      if [[ ! "$middlewares" =~ retry-cold-start ]]; then
        echo "        - retry-cold-start@file" >> "$OUTPUT_FILE"
      fi
    else
      # Add retry middleware even if no other middlewares
      echo "      middlewares:" >> "$OUTPUT_FILE"
      echo "        - retry-cold-start@file" >> "$OUTPUT_FILE"
    fi
  done

  # Generate service definition
  # Format: traefik_http_services_<service-name>_lb_port (shortened from loadbalancer_server_port to fit GCP 63-char limit)
  # Try shortened key first, fallback to full key for backward compatibility
  service_port=$(echo "$labels_json" | jq -r '.["traefik_http_services_'${service_name}'_lb_port"] // .["traefik_http_services_'${service_name}'_loadbalancer_server_port"] // "8080"' 2>/dev/null || echo "8080")

  # Get service_name_from_label from router configs (if any routers were processed)
  # This should have been set in the router loop above
  if [ -z "$service_name_from_label" ]; then
    # Fallback: try to get from label, then use service name
    service_name_from_label=$(echo "$service_json" | jq -r '.spec.template.metadata.labels["traefik_http_services_'${service_name}'_service"] // ""' 2>/dev/null || echo "")
    if [ -z "$service_name_from_label" ]; then
      service_name_from_label="${service_name}"
    fi
    echo "    DEBUG: Service definition: service_name_from_label='${service_name_from_label}' (from fallback)" >&2
  else
    echo "    DEBUG: Service definition: service_name_from_label='${service_name_from_label}' (from router config)" >&2
  fi
  echo "    DEBUG: Already processed services: ${!processed_services[@]}" >&2

  # Check if service already defined
  if [ -z "${processed_services[$service_name_from_label]}" ]; then
    echo "    DEBUG: Service ${service_name_from_label} not yet processed, creating service definition..." >&2
    processed_services[$service_name_from_label]=1

    # Use the token we already fetched (or fetch again if not available)
    # CRITICAL: Use the same service_url for token generation and service definition
    # This ensures token audience matches the request URL
    # NOTE: Always try to fetch token, even for public services, so middleware is ready when service is made private
    token="${service_token}"
    if [ -z "$token" ]; then
      echo "    ðŸ”‘ Fetching token for service definition (using same URL: ${service_url})" >&2
      token=$(get_identity_token "$service_url")
      if [ -z "$token" ] || [[ ! "$token" =~ ^eyJ ]]; then
        echo "    âš ï¸  Token fetch failed - will retry once..." >&2
        sleep 1
        token=$(get_identity_token "$service_url")
      fi
    fi

    # Add service definition
    # CRITICAL: Use the same service_url that was used for token generation
    # This ensures the token audience (service_url) matches the request URL (service_url)
    # If these don't match, Cloud Run will reject the token with 401 Unauthorized
    cat >> "$OUTPUT_FILE" <<SERVICE_EOF

  services:
    ${service_name_from_label}:
      loadBalancer:
        servers:
          - url: "${service_url}"
        passHostHeader: false
SERVICE_EOF
    echo "    âœ… Service definition uses URL: ${service_url} (matches token audience)" >&2

    # Generate auth middleware (always, even if token is empty - it will be fetched at runtime if needed)
    # This ensures middleware exists when service is made private
    echo "    DEBUG: Checking if auth middleware already created for ${service_name_from_label}..." >&2
    echo "    DEBUG: Already created auth middlewares: ${!auth_middlewares[@]}" >&2
    if [ -z "${auth_middlewares[$service_name_from_label]}" ]; then
      echo "    DEBUG: Creating auth middleware for ${service_name_from_label}..." >&2
      echo "    âœ… SUCCESS: Adding auth middleware '${service_name_from_label}-auth' to routes.yml" >&2
      auth_middlewares[$service_name_from_label]=1

      # Check if middlewares section exists
      if ! grep -q "^  middlewares:" "$OUTPUT_FILE"; then
        echo "" >> "$OUTPUT_FILE"
        echo "  middlewares:" >> "$OUTPUT_FILE"
      fi

      if [ -n "$token" ] && [[ "$token" =~ ^eyJ ]]; then
        # Token is available - use it in middleware
        token_esc=$(echo -n "$token" | sed 's/"/\\"/g')
        cat >> "$OUTPUT_FILE" <<AUTH_EOF
    ${service_name_from_label}-auth:
      headers:
        customRequestHeaders:
          Authorization: "Bearer ${token_esc}"
AUTH_EOF
        echo "    âœ… SUCCESS: Auth middleware '${service_name_from_label}-auth' created with token (${#token} chars)" >&2
      else
        # Token not available - this should not happen for Cloud Run services
        # Metadata server should be able to generate tokens for any service URL
        # Token fetch failed - this is unexpected for Cloud Run services
        # Metadata server should be able to generate tokens for any service URL (public or private)
        echo "    âŒ CRITICAL: Token fetch failed for ${service_name_from_label}" >&2
        echo "    ðŸ’¡ This may indicate:" >&2
        echo "       1. Metadata server not accessible (should work in Cloud Run)" >&2
        echo "       2. Service account lacks iam.serviceAccountTokenCreator permission" >&2
        echo "       3. Service URL format issue" >&2
        echo "    âš ï¸  Will retry token fetch one more time..." >&2
        sleep 2
        token=$(get_identity_token "$service_url")
        if [ -n "$token" ] && [[ "$token" =~ ^eyJ ]]; then
          token_esc=$(echo -n "$token" | sed 's/"/\\"/g')
          cat >> "$OUTPUT_FILE" <<AUTH_EOF
    ${service_name_from_label}-auth:
      headers:
        customRequestHeaders:
          Authorization: "Bearer ${token_esc}"
AUTH_EOF
          echo "    âœ… SUCCESS: Auth middleware '${service_name_from_label}-auth' created with token after retry (${#token} chars)" >&2
        else
          echo "    âŒ FAILURE: Token fetch failed after retry for ${service_name_from_label}" >&2
          echo "    DEBUG: Middleware will be created but won't work without token" >&2
          echo "    ðŸ”§ This must be fixed before making service private" >&2
          # Create middleware structure anyway (for visibility), but it won't work
          # The routes will be regenerated on next deployment, and token should be available then
          cat >> "$OUTPUT_FILE" <<AUTH_EOF
    ${service_name_from_label}-auth:
      headers:
        customRequestHeaders:
          Authorization: "Bearer TOKEN_FETCH_FAILED"
AUTH_EOF
          echo "    âš ï¸  WARNING: Auth middleware '${service_name_from_label}-auth' created with error marker - will need token before service is made private" >&2
        fi
      fi
    fi
  fi

  # Clear routers array for next service
  unset routers
  declare -A routers

done <<< "$ALL_SERVICES"

echo ""
echo "âœ… Routes file generated at ${OUTPUT_FILE}"
echo ""
echo "ðŸ“Š Summary:" >&2
# Always emit summary logs (both success and failure cases)
if [ ${#auth_middlewares[@]} -eq 0 ]; then
  echo "   âŒ FAILURE: Auth middlewares created: NONE (no services processed)" >&2
  echo "   DEBUG: No auth middlewares were created - this means no services were successfully processed" >&2
else
  echo "   âœ… SUCCESS: Auth middlewares created: ${!auth_middlewares[@]}" >&2
  echo "   DEBUG: Summary - Created ${#auth_middlewares[@]} auth middleware(s): ${!auth_middlewares[@]}" >&2
fi
if [ ${#processed_services[@]} -eq 0 ]; then
  echo "   âŒ FAILURE: Processed services: NONE (no services found or processing failed)" >&2
  echo "   DEBUG: No services were processed - check logs above for reasons" >&2
else
  echo "   âœ… SUCCESS: Processed services: ${!processed_services[@]}" >&2
  echo "   DEBUG: Summary - Successfully processed ${#processed_services[@]} service(s): ${!processed_services[@]}" >&2
fi
echo ""
router_count=$(grep -c "^    [a-z]" "$OUTPUT_FILE" 2>/dev/null || echo "0")
service_count=$(grep -c "      - url:" "$OUTPUT_FILE" 2>/dev/null || echo "0")
echo "   Routers: ${router_count}"
echo "   Services: ${service_count}"
